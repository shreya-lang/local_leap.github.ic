
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <chrono>
#include <limits>
#include <algorithm>
#include <cctype>
#include <ctime>
#include <conio.h>
using namespace std;

// Enum for Order Status
enum class OrderStatus {
    PENDING,
    CONFIRMED,
    SHIPPED,
    DELIVERED,
    CANCELLED
};
enum ReviewStatus { PENDING, IN_PROGRESS, COMPLETED, REJECTED };
enum UserRole { ADMIN, REVIEWER, SUBMITTER, GUEST };
// Structure to store order items
struct OrderItem {
    string productId;
    string productName;
    string vendorId;
    int quantity;
    float unitPrice;
    float totalPrice;
};

// Structure to store order information
struct Order {
    string orderId;
    int customerId;
    string customerName;
    vector<OrderItem> items;
    float totalAmount;
    OrderStatus status;
    string orderDate;
    string deliveryAddress;
    string paymentMethod;
    bool isPaid;
};

// Vendor structure to hold vendor data
struct Vendor {
    string id;
    string name;
    string contact;
    string businessName;
    string location;
    string password; // New field for storing vendor password
};

// Product structure
struct Product {
    string id;
    string name;
    string category;
    float price;
    int stock;
    string vendorId; // Associate with Vendor ID

};

// Structure to store customer details
struct Customer {
    int id;
    string name;
    string email;
    string phone;
    string password;
     string location;


};

// Helper function for hidden password input
string getHiddenPassword() {
    string password;
#ifdef _WIN32
    char ch;
    while ((ch = _getch()) != '\r') {
        if (ch == '\b' && !password.empty()) {
            password.pop_back();
            cout << "\b \b";
        } else if (isprint(ch)) {
            password += ch;
            cout << "*";
        }
    }
#else
    struct termios oldt, newt;
    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    getline(cin, password);
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    cout << endl;
#endif
    return password;
}

// VendorManager class to handle operations

class VendorManager {
private:
    vector<Vendor> vendors; // In-memory storage of vendors
    const string vendorFile = "vendors.txt"; // File to persist data

    // Helper function to save vendors to file
    void saveToFile() {
        ofstream file(vendorFile);
        if (file.is_open()) {
            for (const auto &vendor : vendors) {
                file << vendor.id << "," << vendor.name << "," << vendor.contact << ","
                     << vendor.businessName << "," << vendor.location << ","
                     << vendor.password << "\n";
            }
            file.close();
        } else {
            cout << "Error: Unable to save data to file!\n";
        }
    }

    // Helper function to load vendors from file
    void loadFromFile() {
        vendors.clear(); // Clear existing data
        ifstream file(vendorFile);
        string line;
        if (file.is_open()) {
            while (getline(file, line)) {
                size_t pos = 0;
                Vendor v;
                vector<string> fields;

                while ((pos = line.find(",")) != string::npos) {
                    fields.push_back(line.substr(0, pos));
                    line.erase(0, pos + 1);
                }
                fields.push_back(line); // Last field

                if (fields.size() == 6) {
                    v.id = fields[0];
                    v.name = fields[1];
                    v.contact = fields[2];
                    v.businessName = fields[3];
                    v.location = fields[4];
                    v.password = fields[5];
                    vendors.push_back(v);
                }
            }
            file.close();
        }
    }

    // Helper function for input validation
    bool isNumber(const string &s) {
        return !s.empty() && all_of(s.begin(), s.end(), ::isdigit);
    }

    bool isAlphabetic(const string &s) {
        return !s.empty() && all_of(s.begin(), s.end(), ::isalpha);
    }

public:
    VendorManager() {
        loadFromFile();
    }

    // Add a new vendor
    void addVendor() {
        Vendor v;
        cout << "Enter Vendor ID (numbers only): ";
        cin >> v.id;
        while (!isNumber(v.id)) {
            cout << "Invalid ID. Please enter numbers only: ";
            cin >> v.id;
        }

        cout << "Enter Vendor Name (alphabets only): ";
        cin.ignore();
        getline(cin, v.name);
        while (!isAlphabetic(v.name)) {
            cout << "Invalid Name. Please enter alphabets only: ";
            getline(cin, v.name);
        }

        cout << "Enter Contact Number (numbers only): ";
        cin >> v.contact;
        while (!isNumber(v.contact)) {
            cout << "Invalid Contact. Please enter numbers only: ";
            cin >> v.contact;
        }

        cout << "Enter Business Name (alphabets only): ";
        cin.ignore();
        getline(cin, v.businessName);
        while (!isAlphabetic(v.businessName)) {
            cout << "Invalid Business Name. Please enter alphabets only: ";
            getline(cin, v.businessName);
        }

        cout << "Enter Location: ";
        getline(cin, v.location);

        cout << "Set a Password (input hidden): ";
        v.password = getHiddenPassword();

        vendors.push_back(v);
        saveToFile();

        cout << "Vendor added successfully!\n";
    }

    // View all vendors
    void viewVendors() {
        if (vendors.empty()) {
            cout << "No vendors registered yet.\n";
            return;
        }
        cout << left << setw(10) << "ID"
             << setw(20) << "Name"
             << setw(15) << "Contact"
             << setw(20) << "Business Name"
             << setw(15) << "Location" << "\n";
        cout << string(80, '-') << "\n";
        for (const auto &v : vendors) {
            cout << left << setw(10) << v.id
                 << setw(20) << v.name
                 << setw(15) << v.contact
                 << setw(20) << v.businessName
                 << setw(15) << v.location << "\n";
        }
    }

    // Login vendor
    void loginVendor() {
        string id, password;
        cout << "Enter Vendor ID (numbers only): ";
        cin >> id;
        while (!isNumber(id)) {
            cout << "Invalid ID. Please enter numbers only: ";
            cin >> id;
        }
        cout << "Enter Password: ";
        password = getHiddenPassword();

        for (const auto &v : vendors) {
            if (v.id == id && v.password == password) {
                cout << "Login successful! Welcome, " << v.name << ".\n";
                return;
            }
        }
        cout << "Invalid ID or Password. Login failed.\n";
    }

    // Edit vendor details
    void editVendor() {
        string id;
        cout << "Enter Vendor ID (numbers only) to edit: ";
        cin >> id;
        while (!isNumber(id)) {
            cout << "Invalid ID. Please enter numbers only: ";
            cin >> id;
        }
        bool found = false;

        for (auto &v : vendors) {
            if (v.id == id) {
                found = true;
                cout << "Editing details for Vendor ID: " << id << "\n";
                cout << "Enter new Vendor Name (alphabets only): ";
                cin.ignore();
                getline(cin, v.name);
                while (!isAlphabetic(v.name)) {
                    cout << "Invalid Name. Please enter alphabets only: ";
                    getline(cin, v.name);
                }

                cout << "Enter new Contact Number (numbers only): ";
                cin >> v.contact;
                while (!isNumber(v.contact)) {
                    cout << "Invalid Contact. Please enter numbers only: ";
                    cin >> v.contact;
                }

                cout << "Enter new Business Name (alphabets only): ";
                cin.ignore();
                getline(cin, v.businessName);
                while (!isAlphabetic(v.businessName)) {
                    cout << "Invalid Business Name. Please enter alphabets only: ";
                    getline(cin, v.businessName);
                }

                cout << "Enter new Location: ";
                getline(cin, v.location);

                cout << "Update Password (input hidden): ";
                v.password = getHiddenPassword();

                saveToFile();

                cout << "Vendor details updated successfully!\n";
                break;
            }
        }

        if (!found) {
            cout << "Vendor with ID " << id << " not found.\n";
        }
    }

    // Delete a vendor
    void deleteVendor() {
        string id;
        cout << "Enter Vendor ID (numbers only) to delete: ";
        cin >> id;
        while (!isNumber(id)) {
            cout << "Invalid ID. Please enter numbers only: ";
            cin >> id;
        }
        bool found = false;

        for (auto it = vendors.begin(); it != vendors.end(); ++it) {
            if (it->id == id) {
                found = true;
                vendors.erase(it);
                saveToFile();
                cout << "Vendor deleted successfully!\n";
                break;
            }
        }

        if (!found) {
            cout << "Vendor with ID " << id << " not found.\n";
        }
    }
};


// ProductManager class to handle product operations
class ProductManager {
private:
    const string productFile = "products.txt";

    // Hidden password input function
    string getHiddenPassword() {
        string password;
#ifdef _WIN32
        char ch;
        while ((ch = _getch()) != '\r') {
            if (ch == '\b' && !password.empty()) {
                password.pop_back();
                cout << "\b \b";
            } else if (isprint(ch)) {
                password += ch;
                cout << "*";
            }
        }
#else
        struct termios oldt, newt;
        tcgetattr(STDIN_FILENO, &oldt);
        newt = oldt;
        newt.c_lflag &= ~(ECHO);
        tcsetattr(STDIN_FILENO, TCSANOW, &newt);
        getline(cin, password);
        tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
        cout << endl;
#endif
        return password;
    }

    // Function to check if a string contains only digits
    bool isNumber(const string &str) {
        return all_of(str.begin(), str.end(), ::isdigit);
    }

    // Function to get the next product ID
    string getNextProductId() {
        ifstream file(productFile);
        string line;
        string lastId = "1"; // Default starting ID

        if (file.is_open()) {
            while (getline(file, line)) {
                size_t pos = line.find(',');
                lastId = line.substr(0, pos); // Get the last product ID
            }
        }
        file.close();

        int nextId = stoi(lastId) + 1; // Increment the ID
        return to_string(nextId);
    }

    // Function to check vendor login
    bool vendorLogin(string &vendorId) {
        string password;
        cout << "Enter Vendor ID (numbers only): ";
        cin >> vendorId;
        while (!isNumber(vendorId)) {
            cout << "Invalid input. Enter numbers only: ";
            cin >> vendorId;
        }
        cout << "Enter Password: ";
        password = getHiddenPassword();

        ifstream file("vendors.txt");
        string line;
        if (file.is_open()) {
            while (getline(file, line)) {
                size_t pos = line.find(',');
                string storedId = line.substr(0, pos);
                line.erase(0, pos + 1);

                for (int i = 0; i < 4; ++i) {
                    pos = line.find(',');
                    line.erase(0, pos + 1);
                }
                string storedPassword = line;

                if (vendorId == storedId && password == storedPassword) {
                    return true;
                }
            }
        }
        cout << "Invalid ID or Password. Login failed.\n";
        return false;
    }

public:
    // Function to add a new product
    void addProduct() {
        string vendorId;
        if (!vendorLogin(vendorId)) {
            return;
        }

        Product p;
        do {
            p.id = getNextProductId(); // Generate the next product ID

            cout << "Auto-generated Product ID: " << p.id << endl;
            cout << "Enter Product Name (alphabets only): ";
            cin.ignore();
            getline(cin, p.name);
            while (!all_of(p.name.begin(), p.name.end(), ::isalpha)) {
                cout << "Invalid input. Enter alphabets only: ";
                getline(cin, p.name);
            }

            cout << "Enter Product Category (alphabets only): ";
            getline(cin, p.category);
            while (!all_of(p.category.begin(), p.category.end(), ::isalpha)) {
                cout << "Invalid input. Enter alphabets only: ";
                getline(cin, p.category);
            }

            cout << "Enter Product Price: ";
            cin >> p.price;
            cout << "Enter Stock Quantity: ";
            cin >> p.stock;
            p.vendorId = vendorId;

            // Save to file
            ofstream file(productFile, ios::app);
            if (file.is_open()) {
                file << p.id << "," << p.name << "," << p.category << "," << p.price << "," << p.stock << "," << p.vendorId << "\n";
                cout << "Product added successfully!\n";
            } else {
                cout << "Error opening file!\n";
            }
            file.close();

            cout << "Do you want to add another product? (yes/no): ";
            string choice;
            cin >> choice;
            if (choice != "yes") {
                break;
            }

        } while (true);
    }

    // Function to display products for a specific vendor
    void displayProducts() {
        string vendorId;
        if (!vendorLogin(vendorId)) {
            return;
        }

        ifstream file(productFile);
        string line;
        bool found = false;

        if (file.is_open()) {
            cout << "\nProducts for Vendor ID: " << vendorId << "\n";
            cout << left << setw(10) << "ID" << setw(20) << "Name" << setw(20) << "Category" << setw(10) << "Price" << setw(10) << "Stock" << endl;
            cout << string(70, '-') << endl;

            while (getline(file, line)) {
                size_t pos = 0;
                vector<string> fields;
                while ((pos = line.find(',')) != string::npos) {
                    fields.push_back(line.substr(0, pos));
                    line.erase(0, pos + 1);
                }
                fields.push_back(line); // Last field

                if (fields.size() == 6 && fields[5] == vendorId) {
                    cout << left << setw(10) << fields[0] << setw(20) << fields[1] << setw(20) << fields[2] << setw(10) << fields[3] << setw(10) << fields[4] << endl;
                    found = true;
                }
            }

            if (!found) {
                cout << "No products found for this vendor.\n";
            }
        } else {
            cout << "Error opening file!\n";
        }
        file.close();
    }

    // Function to update a product
    void updateProduct() {
        string vendorId;
        if (!vendorLogin(vendorId)) {
            return;
        }

        string productId;
        cout << "Enter Product ID to update: ";
        cin >> productId;

        ifstream file(productFile);
        ofstream tempFile("temp.txt");
        string line;
        bool found = false;

        if (file.is_open() && tempFile.is_open()) {
            while (getline(file, line)) {
                size_t pos = 0;
                vector<string> fields;
                while ((pos = line.find(',')) != string::npos) {
                    fields.push_back(line.substr(0, pos));
                    line.erase(0, pos + 1);
                }
                fields.push_back(line); // Last field

                if (fields.size() == 6 && fields[0] == productId && fields[5] == vendorId) {
                    found = true;
                    Product p;
                    p.id = productId;

                    cout << "Enter New Product Name (alphabets only): ";
                    cin.ignore();
                    getline(cin, p.name);
                    while (!all_of(p.name.begin(), p.name.end(), ::isalpha)) {
                        cout << "Invalid input. Enter alphabets only: ";
                        getline(cin, p.name);
                    }

                    cout << "Enter New Product Category (alphabets only): ";
                    getline(cin, p.category);
                    while (!all_of(p.category.begin(), p.category.end(), ::isalpha)) {
                        cout << "Invalid input. Enter alphabets only: ";
                        getline(cin, p.category);
                    }

                    cout << "Enter New Product Price: ";
                    cin >> p.price;
                    cout << "Enter New Stock Quantity: ";
                    cin >> p.stock;
                    p.vendorId = vendorId;

                    tempFile << p.id << "," << p.name << "," << p.category << "," << p.price << "," << p.stock << "," << p.vendorId << "\n";
                    cout << "Product updated successfully!\n";
                } else {
                    tempFile << line << "\n";
                }
            }
        } else {
            cout << "Error opening files!\n";
        }
        file.close();
        tempFile.close();

        // Replace original file with updated file
        remove(productFile.c_str());
        rename("temp.txt", productFile.c_str());

        if (!found) {
            cout << "Product ID not found or you don't have permission to edit it.\n";
        }
    }
void deleteProduct() {
    string vendorId;
    if (!vendorLogin(vendorId)) {
        return;
    }

    string productId;
    cout << "Enter Product ID to delete: ";
    cin >> productId;

    ifstream file("products.txt");
    ofstream tempFile("temp.txt");
    string line;
    bool found = false;

    if (file.is_open() && tempFile.is_open()) {
        while (getline(file, line)) {
            size_t pos = 0;
            vector<string> fields;
            while ((pos = line.find(',')) != string::npos) {
                fields.push_back(line.substr(0, pos));
                line.erase(0, pos + 1);
            }
            fields.push_back(line); // Last field

            if (fields.size() == 6 && fields[0] == productId && fields[5] == vendorId) {
                found = true;
                cout << "Product deleted successfully!\n";
            } else {
                tempFile << line << "\n";
            }
        }
    } else {
        cout << "Error opening files!\n";
    }
    file.close();
    tempFile.close();

    // Replace original file with updated file
    remove("products.txt");
    rename("temp.txt", "products.txt");

    if (!found) {
        cout << "Product ID not found or you don't have permission to delete it.\n";
    }
}};

// CustomerManagement class to handle customer operations

class CustomerManagement {
private:
    vector<Customer> customers;
    int nextCustomerId;
    const string customerFile = "customers.txt";
    int loggedInCustomerId;

    // Helper function to load customer data
    void loadCustomers() {
        ifstream file(customerFile);
        if (!file.is_open()) {
            return; // No file to load from
        }

        string line;
        while (getline(file, line)) {
            stringstream ss(line);
            Customer customer;
            string idStr;

            getline(ss, idStr, ',');
            getline(ss, customer.name, ',');
            getline(ss, customer.email, ',');
            getline(ss, customer.phone, ',');
            getline(ss, customer.password, ',');
            getline(ss, customer.location, ','); // Load location

            customer.id = stoi(idStr);
            customers.push_back(customer);
            nextCustomerId = max(nextCustomerId, customer.id + 1);
        }
        file.close();
    }

    // Helper function to save customer data
    void saveCustomers() {
        ofstream file(customerFile, ios::trunc);
        if (!file.is_open()) {
            cout << "Error saving customers to file." << endl;
            return;
        }

        for (const auto& customer : customers) {
            file << customer.id << "," << customer.name << "," << customer.email << "," << customer.phone << "," << customer.password << "," << customer.location << "\n";
        }

        file.close();
    }

    // Function to validate and get a valid phone number
    string getValidPhoneNumber() {
        string phone;
        do {
            cout << "Enter customer phone (10 digits): ";
            cin >> phone;
            if (phone.length() != 10 || !isNumber(phone)) {
                cout << "Invalid phone number. Please enter exactly 10 digits.\n";
            }
        } while (phone.length() != 10 || !isNumber(phone));
        return phone;
    }

    // Function to validate and append email domain if missing
    string getValidEmail(const string& emailInput) {
        string email = emailInput;
        if (email.find('@') == string::npos) {
            email += "@gmail.com";
        }
        return email;
    }

    // Function to get a valid location
    string getValidLocation() {
        vector<string> locations = {"Shivaji Nagar", "Tilakwadi", "Khanapur Road", "Peeranwadi", "Goa Ves","Tilakwadi","Shahpur"
"Hanuman Nagar","Rani Chennamma Nagar","Vishweswarayya Nagar","Sadashiv Nagar","Shivbasava Nagar","Mandoli Road Area","Vadgaon","Kangrali (BK)","Kangrali (KH)","Deshmukh Road Area","Angol","Mahalaxmi Nagar","Kakti","Hindwadi","Adarsh Nagar","New Goods Shed Road Area","Jadhav Nagar","Yellur"};
        int choice;
        cout << "Available delivery locations in Belagavi, Karnataka:\n";
        for (size_t i = 0; i < locations.size(); ++i) {
            cout << i + 1 << ". " << locations[i] << "\n";
        }
        do {
            cout << "Enter the number corresponding to your location: ";
            cin >> choice;
            if (choice < 1 || choice > locations.size()) {
                cout << "Invalid choice. Please select a valid location.\n";
            }
        } while (choice < 1 || choice > locations.size());
        return locations[choice - 1];
    }

    // Function to validate and get a valid ID
    int getValidId(const string& prompt) {
        string idStr;
        do {
            cout << prompt;
            cin >> idStr;
            if (!isNumber(idStr)) {
                cout << "Invalid ID. Please enter digits only.\n";
            }
        } while (!isNumber(idStr));
        return stoi(idStr);
    }

public:
    CustomerManagement() : nextCustomerId(1), loggedInCustomerId(-1) {
        loadCustomers();
    }

    // Hidden password input function
    string getHiddenPassword() {
        string password;
#ifdef _WIN32
        char ch;
        while ((ch = _getwch()) != '\r') {
            if (ch == '\b' && !password.empty()) {
                password.pop_back();
                cout << "\b \b";
            } else if (isprint(ch)) {
                password += ch;
                cout << "*";
            }
        }
#else
        struct termios oldt, newt;
        tcgetattr(STDIN_FILENO, &oldt);
        newt = oldt;
        newt.c_lflag &= ~(ECHO);
        tcsetattr(STDIN_FILENO, TCSANOW, &newt);
        getline(cin, password);
        tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
        cout << endl;
#endif
        return password;
    }

    // Validation functions
    bool isNumber(const string& s) {
        return !s.empty() && all_of(s.begin(), s.end(), ::isdigit);
    }

    bool isAlphabetic(const string& s) {
        return !s.empty() && all_of(s.begin(), s.end(), ::isalpha);
    }

    // Function to register a new customer
    void addCustomer(const string& name, const string& email, const string& password) {
        for (const auto& customer : customers) {
            if (customer.email == email) {
                cout << "Email already registered. Please use a different email." << endl;
                return;
            }
        }

        if (!isAlphabetic(name)) {
            cout << "Invalid name. Name must contain only alphabets." << endl;
            return;
        }

        string phone = getValidPhoneNumber();
        string validatedEmail = getValidEmail(email);
        string location = getValidLocation();

        Customer newCustomer = {nextCustomerId++, name, validatedEmail, phone, password, location};
        customers.push_back(newCustomer);
        saveCustomers();
        cout << "Customer registered successfully with ID: " << newCustomer.id << endl;
    }

    // Function to log in a customer
    bool loginCustomer(const string& email, const string& password) {
        for (const auto& customer : customers) {
            if (customer.email == email && customer.password == password) {
                loggedInCustomerId = customer.id;
                cout << "Login successful. Welcome, " << customer.name << "!" << endl;
                return true;
            }
        }
        cout << "Invalid email or password." << endl;
        return false;
    }

    // Function to log out
    void logoutCustomer() {
        if (loggedInCustomerId != -1) {
            cout << "Logged out successfully." << endl;
            loggedInCustomerId = -1;
        } else {
            cout << "No user is currently logged in." << endl;
        }
    }

    // Function to update a customer
    void updateCustomer() {
        int id = getValidId("Enter customer ID to update: ");
        for (auto& customer : customers) {
            if (customer.id == id) {
                cout << "Enter password to confirm update: ";
                string password = getHiddenPassword();
                if (password != customer.password) {
                    cout << "Incorrect password. Update canceled." << endl;
                    return;
                }

                string name, email;
                cout << "Enter new customer name (alphabets only): ";
                cin.ignore();
                getline(cin, name);
                while (!isAlphabetic(name)) {
                    cout << "Invalid name. Please enter alphabets only: ";
                    getline(cin, name);
                }

                cout << "Enter new customer email: ";
                getline(cin, email);
                string phone = getValidPhoneNumber();
                string location = getValidLocation();

                customer.name = name;
                customer.email = getValidEmail(email);
                customer.phone = phone;
                customer.location = location;

                cout << "Enter new password: ";
                customer.password = getHiddenPassword();

                saveCustomers();
                cout << "Customer updated successfully!" << endl;
                return;
            }
        }
        cout << "Customer with ID " << id << " not found!" << endl;

         }

    // Function to delete a customer
    void deleteCustomer() {
        int id = getValidId("Enter customer ID to delete: ");
        for (const auto& customer : customers) {
            if (customer.id == id) {
                cout << "Enter password to confirm deletion: ";
                string password = getHiddenPassword();
                if (password != customer.password) {
                    cout << "Incorrect password. Deletion canceled." << endl;
                    return;
                }

                auto it = remove_if(customers.begin(), customers.end(), [id](const Customer& customer) {
                    return customer.id == id;
                });

                if (it != customers.end()) {
                    customers.erase(it, customers.end());
                    saveCustomers();
                    cout << "Customer deleted successfully!" << endl;
                }
                return;
            }
        }
        cout << "Customer with ID " << id << " not found!" << endl;
    }

    // Function to display all customers
    void displayCustomers() {
        if (customers.empty()) {
            cout << "No customers registered." << endl;
            return;
        }

        cout << left << setw(5) << "ID"
             << setw(20) << "Name"
             << setw(25) << "Email"
             << setw(15) << "Phone"
             << setw(25) << "Location" << endl;
        cout << string(90, '-') << endl;

        for (const auto& customer : customers) {
            cout << left << setw(5) << customer.id
                 << setw(20) << customer.name
                 << setw(25) << customer.email
                 << setw(15) << customer.phone
                 << setw(25) << customer.location << endl;
        }
    }
};

// OrderManagement class to handle order operations
class OrderManagement {
private:
    vector<Order> orders;
    const string orderFile = "orders.txt";

    // Helper function to generate order ID
    string generateOrderId() {
        auto now = chrono::system_clock::now();
        auto time = chrono::system_clock::to_time_t(now);
        return "ORD" + to_string(time);
    }

    // Helper function to get current date
    string getCurrentDate() {
        time_t now = time(0);
        char* dt = ctime(&now);
        return string(dt).substr(0, 24); // Remove newline
    }

    // Save orders to file
    void saveOrders() {
        ofstream file(orderFile);
        if (file.is_open()) {
            for (const auto& order : orders) {
                file << order.orderId << "|"
                     << order.customerId << "|"
                     << order.customerName << "|"
                     << static_cast<int>(order.status) << "|"
                     << order.totalAmount << "|"
                     << order.orderDate << "|"
                     << order.deliveryAddress << "|"
                     << order.paymentMethod << "|"
                     << order.isPaid << "||";

                // Save order items
                for (const auto& item : order.items) {
                    file << item.productId << ","
                         << item.productName << ","
                         << item.vendorId << ","
                         << item.quantity << ","
                         << item.unitPrice << ","
                         << item.totalPrice << ";";
                }
                file << "\n";
            }
            file.close();
        }
    }

    // Load orders from file
    void loadOrders() {
        orders.clear();
        ifstream file(orderFile);
        string line;

        if (file.is_open()) {
            while (getline(file, line)) {
                Order order;
                size_t pos = line.find("||");
                string orderInfo = line.substr(0, pos);
                string itemsInfo = line.substr(pos + 2);

                // Parse order information
                vector<string> orderFields;
                stringstream ss(orderInfo);
                string field;
                while (getline(ss, field, '|')) {
                    orderFields.push_back(field);
                }

                if (orderFields.size() >= 9) {
                    order.orderId = orderFields[0];
                    order.customerId = stoi(orderFields[1]);
                    order.customerName = orderFields[2];
                    order.status = static_cast<OrderStatus>(stoi(orderFields[3]));
                    order.totalAmount = stof(orderFields[4]);
                    order.orderDate = orderFields[5];
                    order.deliveryAddress = orderFields[6];
                    order.paymentMethod = orderFields[7];
                    order.isPaid = (orderFields[8] == "1");
 // Parse order items
                    stringstream itemStream(itemsInfo);
                    string item;
                    while (getline(itemStream, item, ';')) {
                        if (!item.empty()) {
                            OrderItem orderItem;
                            vector<string> itemFields;
                            stringstream itemStream(item);
                            string itemField;
                            while (getline(itemStream, itemField, ',')) {
                                itemFields.push_back(itemField);
                            }

                            if (itemFields.size() >= 6) {
                                OrderItem item;
                                item.productId = itemFields[0];
                                item.productName = itemFields[1];
                                item.vendorId = itemFields[2];
                                item.quantity = stoi(itemFields[3]);
                                item.unitPrice = stof(itemFields[4]);
                                item.totalPrice = stof(itemFields[5]);
                                order.items.push_back(item);
                            }
                        }
                    }
                    orders.push_back(order);
                }
            }
            file.close();
        }
    }

    // Validate product availability and get details
    bool validateAndGetProductDetails(const string& productId, int requestedQuantity,
                                      float& unitPrice, string& productName, string& vendorId) {
        ifstream file("products.txt");
        string line;
        bool productFound = false;

        if (file.is_open()) {
            while (getline(file, line)) {
                stringstream ss(line);
                string id, name, category, price, stock, vid;
                getline(ss, id, ',');
                getline(ss, name, ',');
                getline(ss, category, ',');
                getline(ss, price, ',');
                getline(ss, stock, ',');
                getline(ss, vid, ',');

                                if (id == productId) {
                    productFound = true;
                    int availableStock = stoi(stock);
                    if (availableStock >= requestedQuantity) {
                        unitPrice = stof(price);
                        productName = name;
                        vendorId = vid;
                        file.close();
                        return true;
                    }
                    break; // Insufficient stock
                }
            }
            file.close();
        }

        if (!productFound) {
            cout << "Product not found!\n";
        } else {
            cout << "Insufficient stock!\n";
        }
        return false;
    }

    // Update product stock
    void updateProductStock(const string& productId, int quantity) {
        ifstream inFile("products.txt");
        ofstream outFile("products_temp.txt");
        string line;

        if (inFile.is_open() && outFile.is_open()) {
            while (getline(inFile, line)) {
                stringstream ss(line);
                string id, rest;
                getline(ss, id, ',');
                getline(ss, rest);

                if (id == productId) {
                    // Parse the rest of the line
                    stringstream restSS(rest);
                    string name, category, price, stock, vendorId;
                    getline(restSS, name, ',');
                    getline(restSS, category, ',');
                    getline(restSS, price, ',');
                    getline(restSS, stock, ',');
                    getline(restSS, vendorId);

                    int currentStock = stoi(stock);
                    int newStock = currentStock - quantity;

                    // Write updated line
                    outFile << id << "," << name << "," << category << ","
                             << price << "," << newStock << "," << vendorId << "\n";
                } else {
                    outFile << line << "\n";
                }
            }
            inFile.close();
            outFile.close();

            // Replace original file
            remove("products.txt");
            rename("products_temp.txt", "products.txt");
        }
    }

    // Validate customer
    bool validateCustomer(int customerId, string& customerName) {
        ifstream file("customers.txt");
        string line;

        if (file.is_open()) {
            while (getline(file, line)) {
                stringstream ss(line);
                string id, name;
                getline(ss, id, ',');
                getline(ss, name, ',');

                if (stoi(id) == customerId) {
                    customerName = name;
                    file.close();
                    return true;
                }
            }
            file.close();
        }
        return false;
    }

public:
    OrderManagement() {
        loadOrders();
    }

    // Place new order
    void placeOrder() {
        Order newOrder;
        int customerId;
        string customerName;

        cout << "Enter Customer ID: ";
        cin >> customerId;

        if (!validateCustomer(customerId, customerName)) {
            cout << "Invalid customer ID!\n";
            return;
        }

        newOrder.orderId = generateOrderId();
        newOrder.customerId = customerId;
        newOrder.customerName = customerName;
        newOrder.orderDate = getCurrentDate();
        newOrder.status = OrderStatus::PENDING;
        newOrder.isPaid = false;

        cout << "\nEnter delivery address: ";
        cin.ignore();
        getline(cin, newOrder.deliveryAddress);

        // Add items to order
        float totalAmount = 0;
        char addMore;
        do {
            OrderItem item;
            float unitPrice;
            string productName, vendorId;

            cout << "\nEnter Product ID: ";
            cin >> item.productId;
            cout << "Enter quantity: ";
            cin >> item.quantity;

            if (validateAndGetProductDetails(item.productId, item.quantity,
                unitPrice, productName, vendorId)) {
                item.unitPrice = unitPrice;
                item.productName = productName;
                item.vendorId = vendorId;
                item.totalPrice = unitPrice * item.quantity;
                totalAmount += item.totalPrice;
                newOrder.items.push_back(item);
                updateProductStock(item.productId, item.quantity);
            } else {
                cout << "Failed to add product to order.\n";
                continue;
            }

            cout << "Add more items? (y/n): ";
            cin >> addMore;
        } while (toupper(addMore) == 'Y');

        newOrder.totalAmount = totalAmount;

        // Payment method selection
        cout << "\nSelect payment method:\n";
        cout << "1. Cash on Delivery\n";
        cout << "2. Credit Card\n";
        cout << "3. Online Payment\n";
        int paymentChoice;
        cin >> paymentChoice;

        switch (paymentChoice) {
            case 1:
                newOrder.paymentMethod = "Cash on Delivery";
                break;
                        case 2:
                newOrder.paymentMethod = "Credit Card";
                break;
            case 3:
                newOrder.paymentMethod = "Online Payment";
                break;
            default:
                cout << "Invalid choice. Defaulting to Cash on Delivery.\n";
                newOrder.paymentMethod = "Cash on Delivery";
        }

        orders.push_back(newOrder);
        saveOrders();
        cout << "\nOrder placed successfully! Order ID: " << newOrder.orderId << endl;
    }

    // View orders
    void viewOrders() {
        if (orders.empty()) {
            cout << "\nNo orders found.\n";
            return;
        }

        cout << "\nOrder List:\n";
        for (const auto& order : orders) {
            cout << "Order ID: " << order.orderId << endl;
            cout << "Customer: " << order.customerName << endl;
            cout << "Total Amount: " << fixed << setprecision(2) << order.totalAmount << endl;
            cout << "Order Date: " << order.orderDate << endl;
            cout << "Status: " << static_cast<int>(order.status) << endl;
            cout << "Payment Method: " << order.paymentMethod << endl;
            cout << "Delivery Address: " << order.deliveryAddress << endl;

            cout << "Items:\n";
            for (const auto& item : order.items) {
                cout << "Product: " << item.productName << ", Quantity: " << item.quantity
                     << ", Price: " << item.unitPrice << ", Total: " << item.totalPrice << endl;
            }

            cout << "----------------------------------------\n";
        }
    }
};
class User {
private:
    string username;
    string password;
    UserRole role;
    bool isActive;

public:
    User(string uname, string pwd, UserRole r)
        : username(uname), password(pwd), role(r), isActive(true) {}

    string toString() {
        return username + "|" + password + "|" + to_string(role) + "|" + to_string(isActive);
    }

    static User fromString(const string& str) {
        stringstream ss(str);
        string username, password, roleStr, activeStr;
        getline(ss, username, '|');
        getline(ss, password, '|');
        getline(ss, roleStr, '|');
        getline(ss, activeStr, '|');
        return User(username, password, static_cast<UserRole>(stoi(roleStr)));
    }

    string getUsername() { return username; }
    UserRole getRole() { return role; }
    bool authenticate(string pwd) { return password == pwd && isActive; }

    string getPassword() {
        return string(password.length(), '*');  // Return password as asterisks
    }
};
class Review {
private:
    string title;
    string description;
    string author;
    string assignee;
    ReviewStatus status;
    vector<string> comments;
    vector<string> feedback;
    vector<pair<string, int>> ratings;
    double averageRating;

public:
    Review(string t, string desc, string auth)
        : title(t), description(desc), author(auth), status(PENDING), averageRating(0.0) {}

    string toString() {
        stringstream ss;
        ss << title << "|" << description << "|" << author << "|" << assignee << "|" << status << "\n";
        ss << comments.size() << "\n";
        for(const auto& comment : comments) ss << comment << "\n";
        ss << feedback.size() << "\n";
        for(const auto& fb : feedback) ss << fb << "\n";
        ss << ratings.size() << "\n";
        for(const auto& rating : ratings) {
            ss << rating.first << "|" << rating.second << "\n";
        }
        return ss.str();
    }

    static Review fromString(stringstream& ss) {
        string title, description, author, assignee, statusStr;
        string line;
        getline(ss, line);
        stringstream headerSS(line);
        getline(headerSS, title, '|');
        getline(headerSS, description, '|');
        getline(headerSS, author, '|');
        getline(headerSS, assignee, '|');
        getline(headerSS, statusStr, '|');

        Review review(title, description, author);
        review.assignee = assignee;
        review.status = static_cast<ReviewStatus>(stoi(statusStr));

        int count;
        getline(ss, line);
        count = stoi(line);
        for(int i = 0; i < count; i++) {
            getline(ss, line);
            review.comments.push_back(line);
        }

        getline(ss, line);
        count = stoi(line);
        for(int i = 0; i < count; i++) {
            getline(ss, line);
            review.feedback.push_back(line);
        }

        getline(ss, line);
        count = stoi(line);
        for(int i = 0; i < count; i++) {
            getline(ss, line);
            stringstream ratingSS(line);
            string username, ratingStr;
            getline(ratingSS, username, '|');
            getline(ratingSS, ratingStr, '|');
            review.ratings.push_back({username, stoi(ratingStr)});
        }
        review.updateAverageRating();
        return review;
    }

    void addRating(string username, int rating) {
        if(rating < 1 || rating > 5) {
            throw runtime_error("Rating must be between 1 and 5");
        }
        bool found = false;
        for(auto& r : ratings) {
            if(r.first == username) {
                r.second = rating;
                found = true;
                break;
            }
        }
        if(!found) {
            ratings.push_back({username, rating});
        }
        updateAverageRating();
    }

    void updateAverageRating() {
        if(ratings.empty()) {
            averageRating = 0.0;
            return;
        }
        double sum = 0;
        for(const auto& rating : ratings) {
            sum += rating.second;
        }
        averageRating = sum / ratings.size();
    }

    void addComment(string comment) {
        comments.push_back(comment);
    }

    void addFeedback(int feedbackChoice) {
        string feedbackStr;
        switch(feedbackChoice) {
            case 1: feedbackStr = "Excellent"; break;
            case 2: feedbackStr = "Very Good"; break;
            case 3: feedbackStr = "Good"; break;
            case 4: feedbackStr = "Average"; break;
            case 5: feedbackStr = "Bad"; break;
            default: feedbackStr = "Invalid"; break;
        }
        feedback.push_back(feedbackStr);
    }

    void assignTo(string reviewer) {
        assignee = reviewer;
        status = IN_PROGRESS;
    }

    void complete() {
        status = COMPLETED;
    }

    void edit(string newTitle, string newDescription) {
        title = newTitle;
        description = newDescription;
    }

    void displayReview() {
        cout << "\nReview Title: " << title;
        cout << "\nDescription: " << description;
        cout << "\nAuthor: " << author;
        cout << "\nAssigned to: " << (assignee.empty() ? "Not assigned" : assignee);
        cout << "\nAverage Rating: " << (averageRating == 0 ? "No ratings yet" : to_string(averageRating));
        cout << "\nStatus: ";
        switch(status) {
            case PENDING: cout << "Pending"; break;
            case IN_PROGRESS: cout << "In Progress"; break;
            case COMPLETED: cout << "Completed"; break;
            case REJECTED: cout << "Rejected"; break;
        }

        cout << "\n\nRatings:";
        if(ratings.empty()) {
            cout << "\nNo ratings yet.";
        } else {
            for(const auto& rating : ratings) {
                cout << "\n- " << rating.first << ": " << rating.second << "/5";
            }
        }

        cout << "\n\nComments:";
        if(comments.empty()) {
            cout << "\nNo comments yet.";
        } else {
            for(const string& comment : comments) {
                cout << "\n- " << comment;
            }
        }

        cout << "\n\nFeedback Items:";
        if(feedback.empty()) {
            cout << "\nNo feedback yet.";
        } else {
            for(const string& fb : feedback) {
                cout << "\n- " << fb;
            }
        }
        cout << "\n";
    }

    string getTitle() { return title; }
    ReviewStatus getStatus() { return status; }
    double getAverageRating() { return averageRating; }  // Add getter for averageRating
};

class ReviewSystem {
private:
    vector<User> users;
    vector<Review> reviews;
    User* currentUser;
    string dataFile;

    void saveData() {
        ofstream file(dataFile);
        file << users.size() << "\n";
        for(auto& user : users) {
            file << user.toString() << "\n";
        }
        file << reviews.size() << "\n";
        for(auto& review : reviews) {
            file << review.toString();
        }
    }

    void loadData() {
        ifstream file(dataFile);
        if(!file.is_open()) return;

        string line;
        getline(file, line);
        int userCount = stoi(line);

        users.clear();
        for(int i = 0; i < userCount; i++) {
            getline(file, line);
            users.push_back(User::fromString(line));
        }

        getline(file, line);
        int reviewCount = stoi(line);

        reviews.clear();
        stringstream ss;
        for(int i = 0; i < reviewCount; i++) {
            string reviewData;
            while(getline(file, line)) {
                ss << line << "\n";
            }
            if(!ss.str().empty()) {
                reviews.push_back(Review::fromString(ss));
            }
        }
    }

public:
    ReviewSystem() : currentUser(nullptr) {
        dataFile = "review_system.txt";
        loadData();
        if(users.empty()) {
            users.push_back(User("admin", "admin123", ADMIN));
            saveData();
        }
    }

    void registerUser(string username, string password, UserRole role) {
        users.push_back(User(username, password, role));
        saveData();
        cout << "\nUser registered successfully!\n";
    }

    bool login(string username, string password) {
        for(auto& user : users) {
            if(user.getUsername() == username && user.authenticate(password)) {
                currentUser = &user;
                cout << "\nLogged in successfully as " << username << "\n";
                return true;
            }
        }
        cout << "\nLogin failed. Invalid username or password.\n";
        return false;
    }

    void createReview(string title, string description) {
        if(!currentUser || currentUser->getRole() == GUEST) {
            cout << "\nPlease login first!\n";
            return;
        }
        reviews.push_back(Review(title, description, currentUser->getUsername()));
        saveData();
        cout << "\nReview created successfully!\n";
    }

    void editReview(int reviewIndex, string newTitle, string newDescription) {
        if(!currentUser || currentUser->getRole() == GUEST) {
            cout << "\nPlease login first!\n";
            return;
        }
        if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
            cout << "\nInvalid review number!\n";
            return;
        }
        reviews[reviewIndex - 1].edit(newTitle, newDescription);
        saveData();
        cout << "\nReview updated successfully!\n";
    }

    void deleteReview(int reviewIndex) {
        if(!currentUser) {
            cout << "\nPlease login first!\n";
            return;
        }

        string username, password;
        cout << "\nEnter username: ";
        cin >> username;
        cout << "Enter password: ";
        cin >> password;

        if (currentUser->getUsername() == username && currentUser->authenticate(password)) {
            if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
                cout << "\nInvalid review number!\n";
                return;
            }
            reviews.erase(reviews.begin() + (reviewIndex - 1));
            saveData();
            cout << "\nReview deleted successfully!\n";
        } else {
            cout << "\nAuthentication failed. Deletion not allowed.\n";
        }
    }

    void listReviews() {
        if(reviews.empty()) {
            cout << "\nNo reviews available.\n";
            return;
        }

        cout << "\nAvailable Reviews:\n";
        for(int i = 0; i < reviews.size(); i++) {
            cout << i + 1 << ". " << reviews[i].getTitle() << " (Status: ";
            switch(reviews[i].getStatus()) {
                case PENDING: cout << "Pending"; break;
                case IN_PROGRESS: cout << "In Progress"; break;
                case COMPLETED: cout << "Completed"; break;
                case REJECTED: cout << "Rejected"; break;
            }
            cout << ")\n";
        }
    }

    void viewReview(int index) {
        if(index <= 0 || index > reviews.size()) {
            cout << "\nInvalid review index.\n";
            return;
        }
        reviews[index - 1].displayReview();
    }

    void addRating(int reviewIndex, int rating) {
        if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
            cout << "\nInvalid review index.\n";
            return;
        }
        if(currentUser->getRole() == GUEST) {
            cout << "\nGuests cannot rate reviews.\n";
            return;
        }
        reviews[reviewIndex - 1].addRating(currentUser->getUsername(), rating);
        saveData();
        cout << "\nRating added successfully!\n";
    }

    void addFeedback(int reviewIndex) {
        if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
            cout << "\nInvalid review index.\n";
            return;
        }

        int feedbackChoice;
        cout << "\nSelect feedback option:";
        cout << "\n1. Excellent\n2. Very Good\n3. Good\n4. Average\n5. Bad\n";
        cout << "Enter your choice: ";
        cin >> feedbackChoice;

        reviews[reviewIndex - 1].addFeedback(feedbackChoice);
        saveData();
        cout << "\nFeedback added successfully!\n";
    }

    void assignReview(int reviewIndex, string reviewer) {
        if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
            cout << "\nInvalid review index.\n";
            return;
        }
        if(currentUser->getRole() == GUEST) {
            cout << "\nGuests cannot assign reviews.\n";
            return;
        }
        reviews[reviewIndex - 1].assignTo(reviewer);
        saveData();
        cout << "\nReview assigned successfully!\n";
    }

    void completeReview(int reviewIndex) {
        if(reviewIndex <= 0 || reviewIndex > reviews.size()) {
            cout << "\nInvalid review index.\n";
            return;
        }
        reviews[reviewIndex - 1].complete();
        saveData();
        cout << "\nReview marked as completed!\n";
    }

    // Function to filter reviews by rating
    void searchReviewsByRating(int minRating) {
        if(minRating < 1 || minRating > 5) {
            cout << "\nInvalid rating.\n";
            return;
        }
        cout << "\nReviews with rating greater than or equal to " << minRating << ":\n";
        for(int i = 0; i < reviews.size(); i++) {
            if(reviews[i].getAverageRating() >= minRating) {
                cout << i + 1 << ". " << reviews[i].getTitle() << " (Rating: " << reviews[i].getAverageRating() << ")\n";
            }
        }
    }

    // Logout function to reset the currentUser
    void logout() {
        currentUser = nullptr;
        cout << "\nLogged out successfully.\n";
    }
};

// Function to get the password input and mask it with '*'
string getPasswordInput() {
    string password = "";
    char ch;
    while (true) {
        ch = _getch();  // _getch() reads one character from user input
        if (ch == 13) {  // If Enter is pressed, exit loop
            break;
        } else if (ch == 8) {  // Backspace to delete
            if (!password.empty()) {
                password.pop_back();
                cout << "\b \b";  // Erase last character on screen
            }
        } else {
            password.push_back(ch);
            cout << "*";  // Display * for each character typed
        }
    }
    cout << endl;
    return password;
}


//Header Files
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
#include <tuple>
#include <map>
#include <algorithm>
#include <fstream>
#include <iomanip>
#include <ctime>
#include <set>
#include <utility>
#include <string>
#include <cmath>
#include <unordered_map>


using namespace std;


// Constants for max vendors and orders
const int MAX_VENDORS = 100;
const int numLocations = 30; // there are 30 locations



// Structure for a vehicle
struct Vehicle
{
    int id;
    int currentLocation; // Current location index of the vehicle
    double maxCapacity;
    double currentLoad;
    bool isAvailable;
};


// Structure for an order,for assigning to vehicles
struct Order2
{
    int id;
    int deliveryLocation; // Delivery location index
    double weight;
};

// Helper function to format time
std::string formatTime(std::time_t time)
{
    char buffer[20];
    std::strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", std::localtime(&time));
    return std::string(buffer);
}



// Define location names
std::map<int, std::string> locationNames =
{

    {0, "Angol"},
    {1, "Udyambag"},
    {2, "Kamalapur"},
    {3, "Desur"},
    {4, "Channamma Circle"},
    {5, "Bagalkot Galli"},
    {6, "Gokak Galli"},
    {7, "Gadag Galli"},
    {8, "Jamboti Galli"},
    {9, "Khanbhag"},
    {10, "Tilakwadi"},
    {11, "Malmaruti"},
    {12, "APMC Yard"},
    {13, "Fort Galli"},
    {14, "Gandhi Bazar"},
    {15, "Shivaji Nagar"},
    {16, "Venkatapur"},
    {17, "Ambedkar Nagar"},
    {18, "Samyukta Nagar"},
    {19, "RPD Cross"},
    {20, "Vidhya Nagar"},
    {21, "Azad Nagar"},
    {22, "Desai Galli"},
    {23, "Jayanagar"},
    {24, "Anand Nagar"},
    {25, "Ramteerth Nagar"},
    {26, "Mahalaxmi Nagar"},
    {27, "Vidhyanagar"},
    {28, "Katipalla"},
    {29, "Murarji Peth"}

};


// 30x30 distance matrix (example values, replace with actual distances)
std::vector<std::vector<double>>dist =
{

    {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290},
    {10, 0, 15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215, 225, 235, 245, 255, 265, 275, 285},
    {20, 15, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270},
    {30, 25, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260},
    {40, 35, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250},
    {50, 45, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240},
    {60, 55, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230},
    {70, 65, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220},
    {80, 75, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210},
    {90, 85, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200},
    {100, 95, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190},
    {110, 105, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180},
    {120, 115, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170},
    {130, 125, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160},
    {140, 135, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150},
    {150, 145, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140},
    {160, 155, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130},
    {170, 165, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120},
    {180, 175, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110},
    {190, 185, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100},
    {200, 195, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90},
    {210, 205, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70, 80},
    {220, 215, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60, 70},
    {230, 225, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50, 60},
    {240, 235, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40, 50},
    {250, 245, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30, 40},
    {260, 255, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20, 30},
    {270, 265, 250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10, 20},
    {280, 275, 260, 250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0, 10},
    {290, 285, 270, 260, 250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0}

};


std::unordered_map<int, std::string> unorderedLocationNames(locationNames.begin(), locationNames.end());


// Function prototypes

void displayMainMenu();
bool validateLocations(int source, int destination, const std::vector<std::vector<double>>& distanceMatrix);
double adjustSpeedForTimeOfDay(double averageSpeed, const std::string& timeOfDay);
std::vector<std::vector<std::pair<int, int>>> calculateDeliveryTime(const std::vector<std::vector<double>>& distanceMatrix, double adjustedSpeed);
void displayOptimalRoute(const std::vector<std::vector<double>>& distanceMatrix, int source, int destination);
void displayRouteDetails(const std::vector<std::vector<double>>& distanceMatrix, const std::vector<std::vector<std::pair<int, int>>>& deliveryTimeMatrix, double costPerKm, double costPerHour, double fuelEfficiency, int source, int destination);
void displayLocations(const std::unordered_map<int, std::string>& locationNames); // Prototype for displayLocations
void assignVehiclesToOrders(std::vector<Vehicle>& vehicles, std::vector<Order2>& orders, const std::vector<std::vector<double>>& dist, const std::unordered_map<int, std::string>& locationNames);
void resetVehicle(Vehicle& vehicle, int initialLocation);
void updateVehicleLocation(Vehicle& vehicle, int newLocation, const std::unordered_map<int, std::string>& locationNames);
void dijkstra(int source, std::vector<int>& distances, std::vector<bool>& visited, std::vector<int>& previous);
std::vector<int> reconstructPath(int source, int destination, const std::vector<int>& previous);
void savePathToFile(const std::vector<int>& path, const std::unordered_map<int, std::string>& locationNames, const std::string& filename);
std::vector<int> loadPathFromFile(const std::string& filename);
void visualizeMap(const std::vector<int>& path);




// Function to log the reset activity to a file
void logVehicleReset(const Vehicle& vehicle)
{

    std::ofstream logFile("vehicle_reset.log", std::ios_base::app);
    if (logFile.is_open())
    {
        std::time_t now = std::time(nullptr);
        logFile << "Vehicle ID: " << vehicle.id
                << " | Reset at: " << std::ctime(&now)
                << " | New Location: " << vehicle.currentLocation
                << " | New Load: " << vehicle.currentLoad
                << " | Availability: " << (vehicle.isAvailable ? "Yes" : "No") << "\n";
    }

}


// Extended resetVehicle function
void resetVehicle(Vehicle& vehicle, int initialLocation)
{
    vehicle.currentLoad = 0;             // Reset the current load to 0
    vehicle.currentLocation = initialLocation; // Reset to the specified location
    vehicle.isAvailable = true;           // Set the vehicle's availability to true

    // Log the reset activity
    logVehicleReset(vehicle);

    // Print confirmation message to the console
    std::cout << "Vehicle " << vehicle.id << " has been reset.\n"
              << "New Location: " << vehicle.currentLocation << "\n"
              << "New Load: " << vehicle.currentLoad << "\n"
              << "Availability: " << (vehicle.isAvailable ? "Yes" : "No") << std::endl;
}


// Function to log the save operation to a file
void logSaveOperation(const std::string& filename, bool success)
{

    std::ofstream logFile("save_path_log.txt", std::ios_base::app);
    if (logFile.is_open())
    {
        std::time_t now = std::time(nullptr);
        logFile << "Path save operation to " << filename << " at " << std::ctime(&now)
                << "Status: " << (success ? "Success" : "Failure") << "\n";
        logFile.close();
    }
    else
    {
        std::cerr << "Unable to open log file for writing." << std::endl;
    }

}


// Expanded savePathToFile function
void savePathToFile(const std::vector<int>& path, const std::unordered_map<int, std::string>& locationNames, const std::string& filename)
{

    std::ofstream file;
    try
    {
        file.open(filename);
        if (!file)
        {
            throw std::ios_base::failure("Failed to open file.");
        }

        for (int id : path)
        {
            if (locationNames.find(id) != locationNames.end())
            {
                file << locationNames.at(id) << "\n";  // Write location name to file
            }
            else
            {
                std::cerr << "Warning: Location ID " << id << " not found in location names map.\n";
            }
        }

        file.close();
        if (file.fail())
        {
            throw std::ios_base::failure("Failed to write to file.");
        }

        std::cout << "Path successfully saved to " << filename << std::endl;
        logSaveOperation(filename, true);

    }
    catch (const std::exception& e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
        logSaveOperation(filename, false);
    }

}


// Function to log the display operation to a file
void logDisplayOperation(bool success)
{

    std::ofstream logFile("display_locations_log.txt", std::ios_base::app);
    if (logFile.is_open())
    {
        std::time_t now = std::time(nullptr);
        logFile << "Display operation at " << std::ctime(&now)
                << "Status: " << (success ? "Success" : "Failure") << "\n";
        logFile.close();
    }
    else
    {
        std::cerr << "Unable to open log file for writing." << std::endl;
    }

}


// Expanded displayLocations function
void displayLocations(const std::unordered_map<int, std::string>& locationNames)
{

    if (locationNames.empty())
    {
        std::cout << "No available locations to display." << std::endl;
        logDisplayOperation(false);
        return;
    }

    // Convert unordered_map to vector of pairs for sorting
    std::vector<std::pair<int, std::string>> locations(locationNames.begin(), locationNames.end());

    // Sort locations by name
    std::sort(locations.begin(), locations.end(),
              [](const std::pair<int, std::string>& a, const std::pair<int, std::string>& b)
              {
                  return a.second < b.second;
              }
              );

    std::cout << "Available Locations (sorted by name):" << std::endl;
    for (const auto& location : locations)
    {
        std::cout << location.first << ": " << location.second << std::endl;
    }
    std::cout << "==============================" << std::endl;

    logDisplayOperation(true);

}


// Define other function implementations here...
void assignVehiclesToOrders(std::vector<Vehicle>& vehicles, std::vector<Order2>& orders, const std::vector<std::vector<double>>& dist, const std::unordered_map<int, std::string>& locationNames)
{

    for (Order2& order : orders)
    {
        int bestVehicleIndex = -1;
        double minDistance = std::numeric_limits<double>::max();

        // Find the nearest vehicle with sufficient capacity
        for (size_t i = 0; i < vehicles.size(); ++i)
        {
            Vehicle& vehicle = vehicles[i];

            if (vehicle.currentLoad + order.weight <= vehicle.maxCapacity)
            {
                double distance = dist[vehicle.currentLocation][order.deliveryLocation];

                if (distance < minDistance)
                {
                    minDistance = distance;
                    bestVehicleIndex = i;
                }
            }
        }

        // Assign the best vehicle to the order
        if (bestVehicleIndex != -1)
        {
            Vehicle& assignedVehicle = vehicles[bestVehicleIndex];

            std::cout << "Order " << order.id << " is assigned to Vehicle " << assignedVehicle.id << std::endl;

            std::cout << "Delivering to: " << locationNames.at(order.deliveryLocation)
                      << " (Location Index: " << order.deliveryLocation << ")" << std::endl;

            // Update the vehicle's current load and location
            assignedVehicle.currentLoad += order.weight;
            assignedVehicle.currentLocation = order.deliveryLocation;
        }
        else
        {
            std::cout << "Order " << order.id << " could not be assigned to any vehicle!" << std::endl;
        }

        std::cout << std::endl;
    }

}


// Function to log the vehicle location update
void logVehicleLocationUpdate(const Vehicle& vehicle, int oldLocation, int newLocation, bool success)
{

    std::ofstream logFile("vehicle_location_update_log.txt", std::ios_base::app);
    if (logFile.is_open())
    {
        std::time_t now = std::time(nullptr);
        logFile << "Vehicle ID: " << vehicle.id
                << " | Old Location: " << oldLocation
                << " | New Location: " << newLocation
                << " | Update Time: " << std::ctime(&now)
                << " | Status: " << (success ? "Success" : "Failure") << "\n";
        logFile.close();
    }

    else
    {
        std::cerr << "Unable to open log file for writing." << std::endl;
    }

}

// Expanded updateVehicleLocation function
void updateVehicleLocation(Vehicle& vehicle, int newLocation, const std::unordered_map<int, std::string>& locationNames)
{

    // Validate new location
    if (locationNames.find(newLocation) == locationNames.end())
    {
        std::cerr << "Invalid new location. Update failed." << std::endl;
        logVehicleLocationUpdate(vehicle, vehicle.currentLocation, newLocation, false);
        return;
    }

    std::cout << "Vehicle " << vehicle.id << " moved from "
              << locationNames.at(vehicle.currentLocation) << " to "
              << locationNames.at(newLocation) << "." << std::endl;

    int oldLocation = vehicle.currentLocation;
    vehicle.currentLocation = newLocation;

    // Log the location update
    logVehicleLocationUpdate(vehicle, oldLocation, newLocation, true);

}


// Helper function to extract the integer part of the time in hours
int extractHours(double timeInHours)
{

    return static_cast<int>(timeInHours);

}


// Helper function to calculate the fractional part of the time in hours
double calculateFractionalPart(double timeInHours, int hours)
{

    return timeInHours - hours;

}


// Helper function to convert the fractional part to minutes
int convertFractionalPartToMinutes(double fractionalPart)
{

    return static_cast<int>(round(fractionalPart * 60));

}


// Main function to convert time in hours to hours and minutes
std::pair<int, int> convertTimeToHoursAndMinutes(double timeInHours)
{

    // Extract the integer part of the timeInHours to get the hours
    int hours = extractHours(timeInHours);

    // Calculate the fractional part of the timeInHours
    double fractionalPart = calculateFractionalPart(timeInHours, hours);

    // Convert the fractional part to minutes
    int minutes = convertFractionalPartToMinutes(fractionalPart);

    // Return the result as a pair of hours and minutes
    return {hours, minutes};

}


// Function to convert time in hours to hours and minutes
std::pair<int, int> convertTimeToHoursAndMinutes(double timeInHours);


// Helper function to calculate time in hours from distance and speed
double calculateTimeInHours(double distance, double speed)
{

    return distance / speed;

}

// Helper function to initialize the delivery time matrix
std::vector<std::vector<std::pair<int, int>>> initializeDeliveryTimeMatrix(int size)
{

    return std::vector<std::vector<std::pair<int, int>>>(size, std::vector<std::pair<int, int>>(size, {0, 0}));

}


// Function to calculate the delivery time matrix
std::vector<std::vector<std::pair<int, int>>> calculateDeliveryTime(const std::vector<std::vector<double>>& distanceMatrix, double averageSpeed)
{

    int n = distanceMatrix.size();

    // Initialize the delivery time matrix
    std::vector<std::vector<std::pair<int, int>>> deliveryTimeMatrix = initializeDeliveryTimeMatrix(n);

    for (int i = 0; i < n; ++i)
    {
        for (int j = 0; j < n; ++j)
        {
            if (i != j && distanceMatrix[i][j] > 0)
            {
                // Calculate time in hours
                double timeInHours = calculateTimeInHours(distanceMatrix[i][j], averageSpeed);

                // Convert time in hours to hours and minutes
                deliveryTimeMatrix[i][j] = convertTimeToHoursAndMinutes(timeInHours);
            }
        }
    }

    return deliveryTimeMatrix;

}

// Helper function to adjust speed for morning
double adjustSpeedForMorning(double averageSpeed)
{

    return averageSpeed * 0.8; // Morning rush hour

}

// Helper function to adjust speed for afternoon
double adjustSpeedForAfternoon(double averageSpeed)
{

    return averageSpeed * 0.9; // Afternoon traffic

}


// Helper function to adjust speed for evening
double adjustSpeedForEvening(double averageSpeed)
{

    return averageSpeed * 0.7; // Evening peak

}


// Helper function to adjust speed for night
double adjustSpeedForNight(double averageSpeed)
{

    return averageSpeed * 1.1; // Less traffic at night

}


// Main function to dynamically adjust speed based on time of day
double adjustSpeedForTimeOfDay(double averageSpeed, const std::string& timeOfDay)
{

    if (timeOfDay == "morning")
    {
        return adjustSpeedForMorning(averageSpeed);
    }
    if (timeOfDay == "afternoon")
    {
        return adjustSpeedForAfternoon(averageSpeed);
    }
    if (timeOfDay == "evening")
    {
        return adjustSpeedForEvening(averageSpeed);
    }
    if (timeOfDay == "night")
    {
        return adjustSpeedForNight(averageSpeed);
    }
    return averageSpeed; // Default speed

}


// Function to dynamically adjust speed based on time of day
double adjustSpeedForTimeOfDay(double averageSpeed, const std::string& timeOfDay);


// Helper function to print adjusted speed
void printAdjustedSpeed(double averageSpeed, const std::string& timeOfDay)
{

    double adjustedSpeed = adjustSpeedForTimeOfDay(averageSpeed, timeOfDay);
    std::cout << "Adjusted Speed for ";
    std::cout << timeOfDay;
    std::cout << ": ";
    std::cout << adjustedSpeed;
    std::cout << " km/h";
    std::cout << std::endl;

}


// Demonstration function to show usage of adjustSpeedForTimeOfDay
void demonstrateAdjustSpeed()
{

    double averageSpeed = 60.0; // Average speed in km/h

    // Demonstrate for morning
    std::string timeOfDay = "morning";
    printAdjustedSpeed(averageSpeed, timeOfDay);

    // Demonstrate for afternoon
    timeOfDay = "afternoon";
    printAdjustedSpeed(averageSpeed, timeOfDay);

    // Demonstrate for evening
    timeOfDay = "evening";
    printAdjustedSpeed(averageSpeed, timeOfDay);

    // Demonstrate for night
    timeOfDay = "night";
    printAdjustedSpeed(averageSpeed, timeOfDay);

    // Demonstrate for default time (invalid or unspecified)
    timeOfDay = "midnight";
    printAdjustedSpeed(averageSpeed, timeOfDay);

}


// Helper function to check if index is within matrix bounds
bool isIndexWithinBounds(int index, int size)
{

    return index >= 0 && index < size;

}


// Helper function to print invalid index message
void printInvalidIndexMessage(int index, int size)
{

    cout << "Invalid index: " << index << ". Please enter a valid index between 0 and " << size - 1 << "." << endl;

}


// Helper function to print same source and destination message
void printSameSourceDestinationMessage()
{

    cout << "Source and destination must be different." << endl;

}


// Helper function to print no direct route message
void printNoDirectRouteMessage()
{

    cout << "No direct route exists between the selected locations." << endl;

}


// Additional helper function to check if distance matrix is empty
bool isDistanceMatrixEmpty(const vector<vector<double>>& distanceMatrix)
{

    return distanceMatrix.empty();

}


// Additional helper function to check if matrix is square
bool isMatrixSquare(const vector<vector<double>>& distanceMatrix)
{

    for (const auto& row : distanceMatrix)
    {
        if (row.size() != distanceMatrix.size())
        {
            return false;
        }
    }
    return true;

}


// Function to validate locations dynamically
bool validateLocations(int source, int destination, const vector<vector<double>>& distanceMatrix)
{

    int size = distanceMatrix.size();

    // Check if distance matrix is empty
    if (isDistanceMatrixEmpty(distanceMatrix))
    {
        cout << "The distance matrix is empty. Please provide a valid distance matrix." << endl;
        return false;
    }

    // Check if distance matrix is square
    if (!isMatrixSquare(distanceMatrix))
    {
        cout << "The distance matrix is not square. Please provide a valid square matrix." << endl;
        return false;
    }

    // Validate source index
    if (!isIndexWithinBounds(source, size))
    {
        printInvalidIndexMessage(source, size);
        return false;
    }

    // Validate destination index
    if (!isIndexWithinBounds(destination, size))
    {
        printInvalidIndexMessage(destination, size);
        return false;
    }

    // Check if source and destination are the same
    if (source == destination)
    {
        printSameSourceDestinationMessage();
        return false;
    }

    // Check if there is a direct route
    if (distanceMatrix[source][destination] <= 0)
    {
        printNoDirectRouteMessage();
        return false;
    }

    return true;

}


// Function to estimate fuel consumption
double estimateFuelConsumption(double distance, double fuelEfficiency)
{

    // Validate distance
    if (distance <= 0)
    {
        std::cerr << "Error: Distance must be greater than zero." << std::endl;
        throw std::invalid_argument("Invalid distance");
    }

    // Validate fuel efficiency
    if (fuelEfficiency <= 0)
    {
        std::cerr << "Error: Fuel efficiency must be greater than zero." << std::endl;
        throw std::invalid_argument("Invalid fuel efficiency");
    }

    // Calculate fuel consumption
    double fuelConsumption = distance / fuelEfficiency;

    // Log the estimation process
    std::cout << "Estimating fuel consumption..." << std::endl;
    std::cout << "Distance: " << distance << " km" << std::endl;
    std::cout << "Fuel Efficiency: " << fuelEfficiency << " km/l" << std::endl;
    std::cout << "Estimated Fuel Consumption: " << fuelConsumption << " liters" << std::endl;

    return fuelConsumption;

}


// Function to find the shortest path using Dijkstra's algorithm
vector<int> dijkstra(int source, const vector<vector<double>>& distanceMatrix)
{

    int n = distanceMatrix.size();
    vector<double> dist(n, numeric_limits<double>::max());
    vector<int> prev(n, -1);
    vector<bool> visited(n, false);

    dist[source] = 0.0;

    for (int i = 0; i < n; ++i)
    {
        int u = -1;

        for (int v = 0; v < n; ++v)
        {
            if (!visited[v] && (u == -1 || dist[v] < dist[u]))
            {
                u = v;
            }
        }

        if (dist[u] == numeric_limits<double>::max())
        {
            break;
        }

        visited[u] = true;

        for (int v = 0; v < n; ++v)
        {
            if (distanceMatrix[u][v] > 0 && dist[u] + distanceMatrix[u][v] < dist[v])
            {
                dist[v] = dist[u] + distanceMatrix[u][v];
                prev[v] = u;
            }
        }
    }

    return prev;

}


// Function to display optimal route and total distance
void displayOptimalRoute(const vector<vector<double>>& distanceMatrix, int source, int destination)
{

    vector<int> prev = dijkstra(source, distanceMatrix);
    vector<int> path;
    int current = destination;

    while (current != -1)
    {
        path.push_back(current);
        current = prev[current];
    }

    reverse(path.begin(), path.end()); // Fix for the reverse error

    cout << "Optimal Route: ";
    for (int node : path)
    {
        cout << node << " ";
    }
    cout << "| Total Distance: " << distanceMatrix[source][destination] << " km" << endl;

}


// Function to calculate delivery cost
double calculateDeliveryCost(double distance, const pair<int, int>& time, double costPerKm, double costPerHour)
{

    double distanceCost = distance * costPerKm;
    double timeCost = (time.first + time.second / 60.0) * costPerHour;
    return distanceCost + timeCost;

}


// Function to calculate and display route details
void displayRouteDetails
(
    const vector<vector<double>>& distanceMatrix,
    const vector<vector<pair<int, int>>>& timeMatrix,
    double costPerKm,
    double costPerHour,
    double fuelEfficiency,
    int source,
    int destination
)
{

    double distance = distanceMatrix[source][destination];
    pair<int, int> time = timeMatrix[source][destination];
    double routeCost = calculateDeliveryCost(distance, time, costPerKm, costPerHour);
    double fuelUsed = estimateFuelConsumption(distance, fuelEfficiency);

    cout << "Route Details:" << endl;
    cout << "  Distance: " << distance << " km" << endl;
    cout << "  Delivery Time: " << time.first << " hours and " << time.second << " minutes" << endl;
    cout << "  Delivery Cost: " << fixed << setprecision(2) << routeCost << " currency units" << endl;
    cout << "  Estimated Fuel Consumption: " << fixed << setprecision(2) << fuelUsed << " liters" << endl;

}
// Display main menu
void displayMainMenu()
{

    std::cout << "\n--- Delivery Management System ---\n";
    std::cout << "1. Calculate Shortest Path\n";
    std::cout << "2. Calculate delivery time, cost, and fuel efficiency\n";
    std::cout << "3. Vehicle and Order Assignment\n";
    std::cout << "4. Exit\n";
    std::cout << "Enter your choice: ";

}

// Function to find the shortest path from the source node using Dijkstra's algorithm
void dijkstra(int source, std::vector<int>& distances, std::vector<bool>& visited, std::vector<int>& previous)
{

    using P = std::pair<int, int>;  // (distance, node) pair
    std::priority_queue<P, std::vector<P>, std::greater<P>> pq;  // min-heap priority queue
    distances[source] = 0;  // distance to the source is 0
    pq.push({0, source});  // push source node with distance 0

    while (!pq.empty())
    {
        int currentDistance = pq.top().first;  // current shortest distance
        int currentNode = pq.top().second;  // current node
        pq.pop();  // remove the node from the priority queue

        if (visited[currentNode]) continue;  // if already visited, skip

        visited[currentNode] = true;  // mark the current node as visited

        // Explore neighbors
        for (int i = 0; i < numLocations; ++i)
        {
            if (dist[currentNode][i] != 0 && distances[currentNode] + dist[currentNode][i] < distances[i])
            {
                distances[i] = distances[currentNode] + dist[currentNode][i];  // update distance
                pq.push({distances[i], i});  // push neighbor with updated distance
                previous[i] = currentNode;  // update the previous node for the path
            }
        }
    }

}


// Function to reconstruct the path from source to destination
std::vector<int> reconstructPath(int source, int destination, const std::vector<int>& previous)
{

    std::vector<int> path;

    // Check if the destination is reachable
    if (previous[destination] == -1 && source != destination)
    {
        std::cerr << "Error: No path found from " << source << " to " << destination << std::endl;
        return path; // return an empty path
    }

    // Reconstruct the path
    for (int at = destination; at != -1; at = previous[at])
    {
        path.push_back(at);
    }

    std::reverse(path.begin(), path.end());

    // Check if the path starts at the source
    if (path.front() != source)
    {
        std::cerr << "Error: Path reconstruction failed. Starting point does not match the source." << std::endl;
        return std::vector<int>(); // return an empty path
    }

    return path;

}


// Function to save the path to a file
void savePathToFile(const std::vector<int>& path, const std::map<int, std::string>& locationNames, const std::string& filename)
{

    std::ofstream outFile(filename);
    if (outFile.is_open())
    {
        outFile << "Path: ";
        for (size_t i = 0; i < path.size(); ++i)
        {
            outFile << locationNames.at(path[i]);
            if (i != path.size() - 1) outFile << " -> ";
        }
        outFile << std::endl;
        outFile.close();
        std::cout << "\nPath saved to " << filename << std::endl;
    }
    else
    {
        std::cout << "\nUnable to open file " << filename << " for writing." << std::endl;
    }

}


// Function to load the path from a file
std::vector<int> loadPathFromFile(const std::string& filename)
{

    std::vector<int> path;
    std::ifstream inFile(filename);

    // Check if file opened successfully
    if (!inFile.is_open())
    {
        std::cerr << "Error: Could not open file " << filename << std::endl;
        return path;
    }

    std::string line;
    while (std::getline(inFile, line))
    {
        // Process the line and extract location indices
        size_t pos = 0;
        while ((pos = line.find(" -> ")) != std::string::npos)
        {
            std::string loc = line.substr(0, pos);
            // Find the location index by name (reverse lookup)
            auto it = std::find_if(locationNames.begin(), locationNames.end(),
                                   [&loc](const std::pair<int, std::string>& pair) { return pair.second == loc; });
            if (it != locationNames.end())
            {
                path.push_back(it->first);
            }
            else
            {
                std::cerr << "Warning: Location '" << loc << "' not found in locationNames map" << std::endl;
            }
            line.erase(0, pos + 4);
        }

        // Handle the last location after the final " -> "
        auto it = std::find_if(locationNames.begin(), locationNames.end(),
                               [&line](const std::pair<int, std::string>& pair) { return pair.second == line; });
        if (it != locationNames.end())
        {
            path.push_back(it->first);
        }
        else
        {
            std::cerr << "Warning: Location '" << line << "' not found in locationNames map" << std::endl;
        }
    }

    inFile.close();
    return path;

}


// Function to visualize the map and the path
void visualizeMap(const std::vector<int>& path)
{

    if (path.empty())
    {
        std::cout << "\nNo path to visualize.\n";
        return;
    }

    std::cout << "\nPath Visualization:\n";
    int totalDistance = 0;

    for (size_t i = 0; i < path.size(); ++i)
    {
        std::cout << locationNames[path[i]];
        if (i != path.size() - 1)
        {
            int distance = dist[path[i]][path[i + 1]];
            totalDistance += distance;
            std::cout << " -> (" << distance << " km) -> ";
        }
    }

    std::cout << "\nTotal Distance: " << totalDistance << " km" << std::endl;

}




// Main Integrated Module
int main() {
    VendorManager vm;
    ProductManager pm;
    CustomerManagement cm;
    OrderManagement om;
     ReviewSystem reviewSystem;

    int mainChoice;

    do {
        cout << "\n--- Local Vendor Support System ---\n";
        cout << "1. Vendor Management\n";
        cout << "2. Product Management\n";
        cout << "3. Customer Management\n";
        cout << "4. Order Management\n";
        cout << "5. review Management\n";
        cout << "6. Efficient Delivery And Time Management\n";

        cout << "7. Exit\n";

        cout << "Enter your choice: ";
        cin >> mainChoice;

        switch (mainChoice) {
            case 1: {
                int vendorChoice;
                do {
                    cout << "\n--- Vendor Management System ---\n";
                    cout << "1. Add Vendor\n";
                    cout << "2. View Vendors\n";
                    cout << "3. Edit Vendor\n";
                    cout << "4. Delete Vendor\n";
                    cout << "5. Vendor Login\n";
                    cout << "6. Back to Main Menu\n";

                    cout << "Enter your choice: ";
                    cin >> vendorChoice;

                    switch (vendorChoice) {
                        case 1:
                            vm.addVendor();
                            break;
                        case 2:
                            vm.viewVendors();
                            break;
                        case 3:
                            vm.editVendor();
                            break;
                        case 4:
                            vm.deleteVendor();
                            break;
                        case 5:
                            vm.loginVendor();
                            break;
                        case 6:
                            cout << "Returning to Main Menu.\n";
                            break;
                        default:
                            cout << "Invalid choice! Please try again.\n";
                    }
                } while (vendorChoice != 6);
                break;
            }
            case 2: {
                int productChoice;
                do {
                    cout << "\n--- Product Management System ---\n";
                    cout << "1. Add Product\n";
                    cout << "2. Display Products\n";
                    cout << "3. Update Product\n";
                    cout << "4. Delete Product\n";
                    cout << "5. Back to Main Menu\n";

                    cout << "Enter your choice: ";
                    cin >> productChoice;

                    switch (productChoice) {
                        case 1:
                            pm.addProduct();
                            break;
                        case 2:
                            pm.displayProducts();
                            break;
                        case 3:
                            pm.updateProduct();
                            break;
                        case 4:
                            pm.deleteProduct();
                            break;
                        case 5:
                            cout << "Returning to Main Menu.\n";
                            break;
                        default:
                            cout << "Invalid choice! Please try again.\n";
                    }
                } while (productChoice != 5);
                break;
            }
            case 3: { // Customer Management System
                int customerChoice; // Variable for nested menu
                do {
                    cout << "\n--- Customer Management System ---\n";
                    cout << "1. Register Customer\n";
                    cout << "2. Log In\n";
                    cout << "3. Log Out\n";
                    cout << "4. Update Customer\n";

                    cout << "5. Display Customers\n";
                    cout << "6. Delete Customer\n";
                                        cout << "7. Back to Main Menu\n";
                    cout << "Enter your choice: ";
                    cin >> customerChoice;

                    switch (customerChoice) {
                        case 1: {
                          string name, email, password;
                cout << "Enter customer name (alphabets only): ";
                cin.ignore();
                getline(cin, name);
                cout << "Enter customer email: ";
                getline(cin, email);
                cout << "Enter customer password: ";
                password = cm.getHiddenPassword();
                cm.addCustomer(name, email, password);
                break;
            }
                        case 2: {
                           string email, password;
                cout << "Enter email: ";
                cin.ignore();
                getline(cin, email);
                cout << "Enter password: ";
                password = cm.getHiddenPassword();
                cm.loginCustomer(email, password);
                break;
            }
                        case 3:
                            cm.logoutCustomer();
                            break;
                        case 4:
                            cm.updateCustomer();
                            break;
                        case 5:
                            cm.displayCustomers();
                            break;
                        case 6:
                            cm.deleteCustomer();
                            break;
                        case 7:
                            cout << "Returning to Main Menu.\n";
                            break;
                        default:
                            cout << "Invalid choice! Please try again.\n";
                    }
                } while (customerChoice != 7); // Exit nested menu on choice 6
                break;
            }
            case 4: { // Order Management System
                int orderChoice;
                do {
                    cout << "\n--- Order Management System ---\n";
                    cout << "1. Place Order\n";
                    cout << "2. View Orders\n";
                    cout << "3. Back to Main Menu\n";
                    cout << "Enter your choice: ";
                    cin >> orderChoice;

                    switch (orderChoice) {
                        case 1:
                            om.placeOrder();

                            break;
                        case 2:
                            om.viewOrders();
                            break;
                        case 3:
                            cout << "Returning to Main Menu.\n";
                            break;
                        default:
                            cout << "Invalid choice! Please try again.\n";
                    }
                } while (orderChoice != 3);
                break;
            }
            case 5:{
                 int reviewchoice;
                  do {
                    cout << "\n--- review Management System ---\n";

        cout << "\nMenu:\n";
        cout << "1. Register User\n";
        cout << "2. Login\n";
        cout << "3. Create Review\n";
        cout << "4. Edit Review\n";
        cout << "5. Delete Review\n";
        cout << "6. List Reviews\n";
        cout << "7. View Review\n";
        cout << "8. Add Rating\n";
        cout << "9. Add Feedback\n";
        cout << "10. Search Reviews by Rating\n";
        cout << "11. Logout\n";
        cout << "12. Back to Main Menu\n";
        cout << "Enter your choice: ";
         cin >> reviewchoice;

        int reviewIndex, rating, feedbackChoice, minRating;
        string username, password, title, description;
        switch (reviewchoice) {

                case 1:
                cout << "\nEnter username: ";
                cin >> username;
                cout << "Enter password: ";
                password = getPasswordInput();  // Use masked password input
                reviewSystem.registerUser(username, password, REVIEWER);
                break;

                case 2:
                cout << "\nEnter username: ";
                cin >> username;
                cout << "Enter password: ";
                password = getPasswordInput();
                reviewSystem.login(username, password);
                break;


                case 3:
                cout << "\nEnter review number to rate: ";
                cin >> reviewIndex;
                cout << "\nEnter review title: ";
                cin.ignore();
                getline(cin, title);
                cout << "Enter review description: ";
                getline(cin, description);
                reviewSystem.createReview(title, description);
                break;

            case 4:
                cout << "\nEnter review number to edit: ";
                cin >> reviewIndex;
                cout << "Enter new title: ";
                cin.ignore();
                getline(cin, title);
                cout << "Enter new description: ";
                getline(cin, description);
                reviewSystem.editReview(reviewIndex, title, description);
                break;

            case 5:
                cout << "\nEnter review number to delete: ";
                cin >> reviewIndex;
                reviewSystem.deleteReview(reviewIndex);
                break;

            case 6:
                reviewSystem.listReviews();
                break;

            case 7:
                cout << "\nEnter review number to view: ";
                cin >> reviewIndex;
                reviewSystem.viewReview(reviewIndex);
                break;

            case 8:
                cout << "\nEnter review number to rate: ";
                cin >> reviewIndex;
                cout << "Enter rating (1-5): ";
                cin >> rating;
                reviewSystem.addRating(reviewIndex, rating);
                break;

            case 9:
                cout << "\nEnter review number to add feedback: ";
                cin >> reviewIndex;
                reviewSystem.addFeedback(reviewIndex);
                break;

            case 10:
                cout << "\nEnter minimum rating (1-5): ";
                cin >> minRating;
                reviewSystem.searchReviewsByRating(minRating);
                break;

            case 11:
                reviewSystem.logout();
                break;
            case 12:
                            cout << "Returning to Main Menu.\n";
                            break;
                        default:

          cout << "Invalid choice! Please try again.\n";
                    }
                } while (reviewchoice != 12);
                break;
            }
case 6:
           {
                // Populate location names for demonstration
    locationNames =
    {

        {0, "Angol"},
        {1, "Udyambag"},
        {2, "Kamalapur"},
        {3, "Desur"},
        {4, "Channamma Circle"},
        {5, "Bagalkot Galli"},
        {6, "Gokak Galli"},
        {7, "Gadag Galli"},
        {8, "Jamboti Galli"},
        {9, "Khanbhag"},
        {10, "Tilakwadi"},
        {11, "Malmaruti"},
        {12, "APMC Yard"},
        {13, "Fort Galli"},
        {14, "Gandhi Bazar"},
        {15, "Shivaji Nagar"},
        {16, "Venkatapur"},
        {17, "Ambedkar Nagar"},
        {18, "Samyukta Nagar"},
        {19, "RPD Cross"},
        {20, "Vidhya Nagar"},
        {21, "Azad Nagar"},
        {22, "Desai Galli"},
        {23, "Jayanagar"},
        {24, "Anand Nagar"},
        {25, "Ramteerth Nagar"},
        {26, "Mahalaxmi Nagar"},
        {27, "Vidhyanagar"},
        {28, "Katipalla"},
        {29, "Murarji Peth"}

    };

    // Initialize the distance matrix with some values (example)
    dist =
    {

        {0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290},
        {10, 0, 15, 25, 35, 45, 55, 65, 75, 85, 95, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215, 225, 235, 245, 255, 265, 275, 285},
        {20, 15, 0, 17, 27, 37, 47, 57, 67, 77, 87, 97, 107, 117, 127, 137, 147, 157, 167, 177, 187, 197, 207, 217, 227, 237, 247, 257, 267, 277},
        {30, 25, 17, 0, 22, 32, 42, 52, 62, 72, 82, 92, 102, 112, 122, 132, 142, 152, 162, 172, 182, 192, 202, 212, 222, 232, 242, 252, 262, 272},
        {40, 35, 27, 22, 0, 19, 29, 39, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159, 169, 179, 189, 199, 209, 219, 229, 239, 249, 259},
        {50, 45, 37, 32, 19, 0, 24, 34, 44, 54, 64, 74, 84, 94, 104, 114, 124, 134, 144, 154, 164, 174, 184, 194, 204, 214, 224, 234, 244, 254},
        {60, 55, 47, 42, 29, 24, 0, 26, 36, 46, 56, 66, 76, 86, 96, 106, 116, 126, 136, 146, 156, 166, 176, 186, 196, 206, 216, 226, 236, 246},
        {70, 65, 57, 52, 39, 34, 26, 0, 28, 38, 48, 58, 68, 78, 88, 98, 108, 118, 128, 138, 148, 158, 168, 178, 188, 198, 208, 218, 228, 238},
        {80, 75, 67, 62, 49, 44, 36, 28, 0, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230},
        {90, 85, 77, 72, 59, 54, 46, 38, 30, 0, 33, 43, 53, 63, 73, 83, 93, 103, 113, 123, 133, 143, 153, 163, 173, 183, 193, 203, 213, 223},
        {100, 95, 87, 82, 69, 64, 56, 48, 40, 33, 0, 36, 46, 56, 66, 76, 86, 96, 106, 116, 126, 136, 146, 156, 166, 176, 186, 196, 206, 216},
        {110, 105, 97, 92, 79, 74, 66, 58, 50, 43, 36, 0, 39, 49, 59, 69, 79, 89, 99, 109, 119, 129, 139, 149, 159, 169, 179, 189, 199, 209},
        {120, 115, 107, 102, 89, 84, 76, 68, 60, 53, 46, 39, 0, 52, 62, 72, 82, 92, 102, 112, 122, 132, 142, 152, 162, 172, 182, 192, 202, 212},
        {130, 125, 117, 112, 99, 94, 86, 78, 70, 63, 56, 49, 52, 0, 65, 75, 85, 95, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215},
        {140, 135, 127, 122, 109, 104, 96, 88, 80, 73, 66, 59, 62, 65, 0, 85, 95, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215, 225},
        {150, 145, 137, 132, 119, 114, 106, 98, 90, 83, 76, 69, 72, 75, 85, 0, 105, 115, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215, 225, 235},
        {160, 155, 147, 142, 129, 124, 116, 108, 100, 93, 86, 79, 82, 85, 95, 105, 0, 125, 135, 145, 155, 165, 175, 185, 195, 205, 215, 225, 235, 245},
        {170, 165, 157, 152, 139, 134, 126, 118, 110, 103, 96, 89, 92, 95, 105, 115, 125, 0, 145, 155, 165, 175, 185, 195, 205, 215, 225, 235, 245, 255},
        {180, 175, 167, 162, 149, 144, 136, 128, 120, 113, 106, 99, 102, 105, 115, 125, 135, 145, 0, 165, 175, 185, 195, 205, 215, 225, 235, 245, 255, 265},
        {190, 185, 177, 172, 159, 154, 146, 138, 130, 123, 116, 109, 112, 115, 125, 135, 145, 155, 165, 0, 185, 195, 205, 215, 225, 235, 245, 255, 265, 275},
        {200, 195, 187, 182, 169, 164, 156, 148, 140, 133, 126, 119, 122, 125, 135, 145, 155, 165, 175, 185, 0, 205, 215, 225, 235, 245, 255, 265, 275, 285},
        {210, 205, 197, 192, 179, 174, 166, 158, 150, 143, 136, 129, 132, 135, 145, 155, 165, 175, 185, 195, 205, 0, 225, 235, 245, 255, 265, 275, 285, 295},
        {220, 215, 207, 202, 189, 184, 176, 168, 160, 153, 146, 139, 142, 145, 155, 165, 175, 185, 195, 205, 215, 225, 0, 245, 255, 265, 275, 285, 295, 305},
        {230, 225, 217, 212, 199, 194, 186, 178, 170, 163, 156, 149, 152, 155, 165, 175, 185, 195, 205, 215, 225, 235, 245, 0, 265, 275, 285, 295, 305, 315},
        {240, 235, 227, 222, 209, 204, 196, 188, 180, 173, 166, 159, 162, 165, 175, 185, 195, 205, 215, 225, 235, 245, 255, 265, 0, 285, 295, 305, 315, 325},
        {250, 245, 237, 232, 219, 214, 206, 198, 190, 183, 176, 169, 172, 175, 185, 195, 205, 215, 225, 235, 245, 255, 265, 275, 285, 0, 305, 315, 325, 335},
        {260, 255, 247, 242, 229, 224, 216, 208, 200, 193, 186, 179, 182, 185, 195, 205, 215, 225, 235, 245, 255, 265, 275, 285, 295, 305, 0, 325, 335, 345},
        {270, 265, 257, 252, 239, 234, 226, 218, 210, 203, 196, 189, 192, 195, 205, 215, 225, 235, 245, 255, 265, 275, 285, 295, 305, 315, 325, 0, 345, 355},
        {280, 275, 267, 262, 249, 244, 236, 228, 220, 213, 206, 199, 202, 205, 215, 225, 235, 245, 255, 265, 275, 285, 295, 305, 315, 325, 335, 345, 0, 365},
        {290, 285, 277, 272, 259, 254, 246, 238, 230, 223, 216, 209, 212, 215, 225, 235, 245, 255, 265, 275, 285, 295, 305, 315, 325, 335, 345, 355, 365, 0}

    };

    // Convert distance matrix to double type
    std::vector<std::vector<double>> distanceMatrix(dist.begin(), dist.end());

   int mainChoice; // Declare mainChoice
    while (mainChoice!=4)
    {

        displayMainMenu();
        std::cin >> mainChoice;

        switch (mainChoice)
        {
            case 1: // Location and Path Management
            {
                int source, destination;

                // Display all locations
                std::cout << "\nLocations:\n";
                for (const auto& pair : locationNames)
                {
                    std::cout << pair.first << ". " << pair.second << std::endl;
                }

                // Input validation for source
                while (true)
                {
                    std::cout << "\nEnter the source location index (0-29): ";
                    std::cin >> source;
                    if (source >= 0 && source < locationNames.size()) break;
                    std::cout << "Invalid input. Please enter a number between 0 and 29." << std::endl;
                }

                // Input validation for destination
                while (true)
                {
                    std::cout << "Enter the destination location index (0-29): ";
                    std::cin >> destination;
                    if (destination >= 0 && destination < locationNames.size()) break;
                    std::cout << "Invalid input. Please enter a number between 0 and 29." << std::endl;
                }

                std::vector<int> distances(locationNames.size(), std::numeric_limits<int>::max());  // initialize distances with max value
                std::vector<bool> visited(locationNames.size(), false);  // initialize visited array
                std::vector<int> previous(locationNames.size(), -1);  // track the previous node in the path

                // Apply Dijkstra's algorithm from source node
                dijkstra(source, distances, visited, previous);

                // Display the shortest distance from source to destination
                std::cout << "\nShortest distance from location " << source << " (" << locationNames[source]
                          << ") to location " << destination << " (" << locationNames[destination] << ") is: "
                          << distances[destination] << " km" << std::endl;

                // Reconstruct and display the path
                std::vector<int> path = reconstructPath(source, destination, previous);

                std::cout << "Path: ";
                for (size_t i = 0; i < path.size(); ++i)
                {
                    std::cout << locationNames[path[i]];
                    if (i != path.size() - 1) std::cout << " -> ";
                }
                std::cout << std::endl;

                // Save the path to a file
                savePathToFile(path, unorderedLocationNames, "path.txt");

                // Load the path from a file (for demonstration purposes)
                std::vector<int> loadedPath = loadPathFromFile("path.txt");
                if (!loadedPath.empty())
                {
                    std::cout << "Loaded Path: ";
                    for (size_t i = 0; i < loadedPath.size(); ++i)
                    {
                        std::cout << locationNames[loadedPath[i]];
                        if (i != loadedPath.size() - 1) std::cout << " -> ";
                    }
                    std::cout << std::endl;
                }

                // Visualize the map and the path
                visualizeMap(path);
                break;
            }

            case 2: // Delivery Management
            {
                int source, destination;
                std::string timeOfDay;
                double averageSpeed, costPerKm, costPerHour, fuelEfficiency;

                // Display all locations
                std::cout << "\nAvailable Locations:\n";
                for (const auto& location : locationNames)
                {
                    std::cout << location.first << ": " << location.second << std::endl;
                }

                std::cout << "Enter source location index (0-29): ";
                std::cin >> source;
                std::cout << "Enter destination location index (0-29): ";
                std::cin >> destination;
                std::cout << "Enter average speed (km/h): ";
                std::cin >> averageSpeed;
                std::cout << "Enter time of day (morning, afternoon, evening): ";
                std::cin >> timeOfDay;
                cin.ignore(10000, '\n');
                std::cout << "Enter cost per km:\n ";
                std::cin >> costPerKm;
                cin.ignore(10000, '\n');
                std::cout << "Enter cost per hour:\n ";
                std::cin >> costPerHour;
                cin.ignore(10000, '\n');
                std::cout << "Enter fuel efficiency (km/l): \n";
                std::cin >> fuelEfficiency;

                if (!validateLocations(source, destination, dist))
                {
                    return 1;
                }

                double adjustedSpeed = adjustSpeedForTimeOfDay(averageSpeed, timeOfDay);
                std::vector<std::vector<std::pair<int, int>>> deliveryTimeMatrix = calculateDeliveryTime(dist, adjustedSpeed);

                displayOptimalRoute(dist, source, destination);
                displayRouteDetails(dist, deliveryTimeMatrix, costPerKm, costPerHour, fuelEfficiency, source, destination);

                break;
            }

            case 3: // Vehicle and Order Assignment
            {
            // Display all locations
            displayLocations(unorderedLocationNames);

            // Input number of vehicles and their details
            int numVehicles;
            std::cout << "Enter the number of vehicles: ";
            std::cin >> numVehicles;

            std::vector<Vehicle> vehicles(numVehicles);
            for (int i = 0; i < numVehicles; ++i)
            {
                vehicles[i].id = i + 1;
                std::cout << "Enter details for Vehicle " << vehicles[i].id
                          << " (currentLocation maxCapacity currentLoad): ";
                std::cin >> vehicles[i].currentLocation
                         >> vehicles[i].maxCapacity
                         >> vehicles[i].currentLoad;
            }

            std::cout << std::endl;

            // Input number of orders and their details
            int numOrders;
            std::cout << "Enter the number of orders: ";
            std::cin >> numOrders;

            std::vector<Order2> orders(numOrders);
            for (int i = 0; i < numOrders; ++i)
            {
                orders[i].id = i + 1;
                std::cout << "Enter details for Order " << orders[i].id
                          << " (deliveryLocation weight): ";
                std::cin >> orders[i].deliveryLocation
                         >> orders[i].weight;
            }

            std::cout << "\nAssigning Vehicles to Orders:\n";
            std::cout << "==============================\n";

            // Assign vehicles to orders
            assignVehiclesToOrders(vehicles, orders, dist, unorderedLocationNames);

            // Reset a specific vehicle for demonstration
            resetVehicle(vehicles[0], 0);
            std::cout << "\nVehicle 1 has been reset to initial location and load.\n";

            // Update location of a specific vehicle
            updateVehicleLocation(vehicles[0], 2, unorderedLocationNames);

            break;
            }

            case 4: // Exit
                std::cout << "Exiting...\n";
                exit;


        }

    }

           }
case 7:
                cout <<"Returning to Main Menu\n"                                                                                                                                                                                                                                   ;
                break;

        }
    }while (mainChoice != 7); // Exit program on choice 5

    return 0;
}

